<!DOCTYPE HTML>
<html>
	<head>
		<title>Spectrogram viewer</title>
		<meta charset="UTF-8">
		<style>
			#canvasdiv {
				width: 100%;
				/*height: 500px;*/
				overflow-x: scroll;
				padding: 0;
				border: 0;
			}
			canvas {
				padding: 0;
				border: 0;
			}
			input {
				width: 100%;
			}
			table {
				width: 100%;
			}
			td.a {
				width: 10em;
			}
		</style>
	</head>
	<body>
		<div id="canvasdiv"><canvas id="canvas"></canvas></div>
		<p id="info"></p>
		<table>
		<tr>
			<td class="a">Palette contrast</td>
			<td class="b"><input type="range" id="slider1" onchange="update_colors()"
				min="0" max="50" step="0.5" value="10"></td>
		</tr>
		<tr>
			<td class="a">Palette offset</td>
			<td class="b"><input type="range" id="slider2" onchange="update_colors()"
				min="0" max="250" step="1" value="30"></td>
		</tr>
		<tr>
			<td class="a">Time scroll</td>
			<td class="b"><input type="range" id="slider3" onchange="update_zoom()"
				min="0" max="1000" step="250" value="0"></td>
		</tr>
		<tr>
			<td class="a">Time zoom</td>
			<td class="b"><input type="range" id="slider4" onchange="update_zoom()"
				min="-8" max="1" step="1" value="-2"></td>
		</tr>
		<tr>
			<td class="a">Frequency scroll</td>
			<td class="b"><input type="range" id="slider5" onchange="update_zoom()"
				min="0" max="1000" step="250" value="0"></td>
		</tr>
		<tr>
			<td class="a">Frequency zoom</td>
			<td class="b"><input type="range" id="slider6" onchange="update_zoom()"
				min="-4" max="1" step="1" value="-2"></td>
		</tr>
		<tr>
			<td class="a">Data file</td>
			<td class="b"><input type="file" id="fileinput"></td>
		</tr>
		</table>
	</body>
	<script type="application/javascript">
		/*
		 * Parameters
		 */
		var bins; // Number of bins
		var nrecords = 0; // Number of records in loaded file
		var bin_khz; // Spacing of bins in kHz
		var canvasw, canvash; // Size of the canvas
		var pixel0_khz; // First pixel in kHz
		var pixel_khz; // Spacing of pixels in kHz

		/* Various objects */
		const reader = new FileReader();
		const canvas = document.getElementById("canvas");
		const slider1 = document.getElementById("slider1");
		const slider2 = document.getElementById("slider2");
		const slider3 = document.getElementById("slider3");
		const slider4 = document.getElementById("slider4");
		const slider5 = document.getElementById("slider5");
		const slider6 = document.getElementById("slider6");
		const info = document.getElementById("info");
		const ctx = canvas.getContext("2d");

		var img; // ImageData used to draw a line to the canvas
		var imgdata; // Uint32Array view to img
		var view = null; // View to the data file
		/* Intermediate Uint16Array for data after zooming
		 * but before mapping to a palette */
		var zoomed;

		/*
		 * Precalculate color palette.
		 *
		 * View both the image data and the palette as Uint32Arrays
		 * so that all 4 bytes of a pixel can be copied at once
		 * and indexing becomes simpler.
		 */
		function generate_palette() {
			const colors = [[0,0,0], [0,0,255], [255,128,0], [255,255,255]];
			const gradientlen = 0x100;
			const palette = new Uint8Array(4 * gradientlen * (colors.length-1));
			i = 0;
			for (let c=0; c<colors.length-1; c++) {
				for(let j=0; j<gradientlen; j++) {
					const b = j / gradientlen;
					const a = 1.0 - b;
					palette[i++] = Math.round(a * colors[c][0] + b * colors[c+1][0]);
					palette[i++] = Math.round(a * colors[c][1] + b * colors[c+1][1]);
					palette[i++] = Math.round(a * colors[c][2] + b * colors[c+1][2]);
					palette[i++] = 255;
				}
			}
			return new Uint32Array(palette.buffer);
		};
		const paldata = generate_palette();


		function set_canvas_size(w, h) {
			w = Math.round(w);
			h = Math.round(h);
			canvas.width = w;
			canvas.height = h;
			canvasw = w;
			canvash = h;
			img = ctx.createImageData(w, 1);
			zoomed = new Uint16Array(w * h);
			imgdata = new Uint32Array(img.data.buffer);
		}

		set_canvas_size(1200,500);

		/* Calculate relevant parameters based on FFT size and sample rate */
		function set_data_parameters(fftsize, fs) {
			bins = Math.round(fftsize / 2 + 1);
			bin_khz = fs / fftsize / 1000;
		}

		function update_slider_bounds() {
			slider5.value = 0;
			slider5.max = bins;
			slider3.value = 0;
			slider3.max = nrecords;
		}

		set_data_parameters(16384, 100e6);
		update_slider_bounds();


		/* Draw an image to the canvas based on zoomed data
		 * and color palette settings */
		function update_colors() {
			const multiplier = slider1.value * 1;
			const offset = slider2.value * 1;

			const palmax = paldata.length - 1;

			let zi=0;
			for (let y=0; y<canvash; y++) {
				for (let x=0; x<canvasw; x++) {
					let v = ((zoomed[zi++] - offset) * multiplier);
					v = Math.min(Math.max(Math.round(v), 0), palmax);
					imgdata[x] = paldata[v];
				}
				ctx.putImageData(img, 0, y);
			}
		}

		function update_zoom() {
			const fx_offset = Math.round(slider5.value);
			const fy_offset = Math.round(slider3.value);
			pixel0_khz = bin_khz * fx_offset;

			const zoomx = Math.pow(0.5, slider6.value);
			const zoomy = Math.pow(0.5, slider4.value);
			const zoomxi = Math.max(1, Math.round(zoomx));
			const zoomyi = Math.max(1, Math.round(zoomy));
			pixel_khz = bin_khz * zoomx;

			if (view == null) return;

			let zi=0;
			for (let y=0; y<canvash; y++) {
				for (let x=0; x<canvasw; x++) {
					// Bounds of the rectangle of bins under one pixel
					let fx0 = fx_offset + Math.floor(x * zoomx);
					let fy0 = fy_offset + Math.floor(y * zoomy);
					let fx1 = fx0 + zoomxi;
					let fy1 = fy0 + zoomyi;
					let m = 0;
					if (fx1 <= bins && fy1 <= nrecords) {
						// Find the maximum value under one pixel
						for (let fy=fy0; fy<fy1; fy++) {
							for (let fx=fx0; fx<fx1; fx++) {
								m = Math.max(m, view[bins * fy + fx]);
							}
						}
					}
					zoomed[zi++] = m;
				}
			}

			update_colors();
		}

		/*
		 * Javascript magic to load a file
		 */
		function file_loaded(ev) {
			const d = ev.target.result;
			view = new Uint8Array(d);

			nrecords = Math.floor(view.length / bins);
			update_slider_bounds();

			update_zoom();
		}
		reader.addEventListener("load", file_loaded);
		function file_changed(ev) {
			reader.readAsArrayBuffer(ev.target.files[0]);
		}
		document.getElementById("fileinput").
		addEventListener("change", file_changed);

		/*
		 * Info field.
		 * TODO: handle zoom and scroll correctly
		 */
		function update_info(ev) {
			info.innerText = "" + (pixel0_khz + pixel_khz * ev.offsetX).toFixed(1) + " kHz";
		}
		canvas.addEventListener("mousemove", update_info);

		update_zoom();
	</script>
</html>
