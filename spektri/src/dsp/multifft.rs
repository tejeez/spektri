//! Calculation of multiple FFTs in parallel

use rustfft::{FftPlanner, num_complex::Complex};
use rayon::prelude::*;

pub struct MultiFft {
    fft: std::sync::Arc<dyn rustfft::Fft<f32>>, // RustFFT plan
}

/// Apply a real-valued window function to a complex signal.
fn apply_window(
    window: &[f32],
    input: &[Complex<f32>],
    output: &mut[Complex<f32>]
) {
    for (o, (i, w)) in output.iter_mut().zip(input.iter().zip(window.iter())) {
        *o = Complex{
            re: i.re * w,
            im: i.im * w
        };
    }
}

impl MultiFft {
    pub fn init(fft_size: usize) -> MultiFft {
        let mut planner = FftPlanner::new();
        MultiFft {
            fft: planner.plan_fft_forward(fft_size),
        }
    }

    /// Calculate multiple FFTs with a window function
    /// for complex input signal.
    pub fn process_complex(
        &self,
        window: &[f32],
        inputs: &[&[Complex<f32>]],
        outputs: &mut[&mut [Complex<f32>]]
    ) {
        outputs.par_iter_mut().zip(inputs.par_iter()).for_each(
        |(output, input)| {
            // RustFFT does transform in-place, so temporarily
            // write the windowed signal into the output buffer
            apply_window(window, input, *output);
            self.fft.process(*output);
        });
    }

    /// Calculate multiple FFTs with a window function
    /// for real input signal.
    pub fn process_real(
        &self,
        window: &[f32],
        inputs: &[&[f32]],
        outputs: &mut[&mut [Complex<f32>]]
    ) {
        outputs.par_chunks_mut(2).zip(inputs.par_chunks(2)).for_each(
        |(output, input)| {
            let (output0, output1) = output.split_at_mut(1);
            self.two_real_ffts(window, input[0], input[1], output0[0], output1[0]);
        });
    }

    /// Calculate two real-input-valued FFTs in one complex FFT.
    fn two_real_ffts(
        &self,
        window: &[f32],
        input0: &[f32],
        input1: &[f32],
        output0: &mut [Complex<f32>],
        output1: &mut [Complex<f32>],
    ) {
        // First, place one signal in real and the other in imaginary part:
        let mut buf: Vec<Complex<f32>> =
            input0.iter().zip(input1.iter()).zip(window.iter())
            .map(|((in0, in1), w)| { Complex{re: *in0 * w, im: *in1 * w} })
            .collect::<Vec<Complex<f32>>>();
        // Complex transform:
        self.fft.process(&mut buf);
        let n = buf.len(); // FFT size
        // Extract the results:
        output0.iter_mut().zip(output1.iter_mut()).enumerate().
        for_each(|(i, (out0, out1))| {
            let r = buf[i]; // One bin from result
            let m = buf[if i==0 {0} else {n-i}]; // One bin from mirrored result
            *out0 = Complex{
                re: 0.5*( r.re +m.re),
                im: 0.5*( r.im -m.im)
            };
            *out1 = Complex{
                re: 0.5*( r.im +m.im),
                im: 0.5*(-r.re +m.re)
            };
        });
    }
}

#[test]
fn test_two_real_ffts() {
    let mfft = MultiFft::init(8);

    let mut out0 = vec![Complex::<f32>{re:0.0, im:0.0}; 5];
    let mut out1 = vec![Complex::<f32>{re:0.0, im:0.0}; 5];

    // Use random numbers generated by real_fft_test.py
    let mut expected_out0: Vec<Complex::<f32>> = vec![
        Complex{re:2.223027,im:0.000000},Complex{re:-0.597695,im:0.505358},Complex{re:0.806623,im:0.495951},Complex{re:-0.996137,im:0.008528},Complex{re:0.548702,im:0.000000}
    ];
    let mut expected_out1: Vec<Complex::<f32>> = vec![
        Complex{re:2.126119,im:0.000000},Complex{re:0.087119,im:-0.050957},Complex{re:0.120544,im:0.847065},Complex{re:-0.558032,im:-0.341957},Complex{re:-1.265481,im:0.000000}
    ];

    mfft.two_real_ffts(
        &vec![0.255869,0.587904,0.053698,0.806051,0.985976,0.193814,0.317653,0.825301],
        &vec![0.584925,0.110384,0.383683,0.213386,0.960043,0.545424,0.846892,0.599244],
        &vec![0.078116,0.673051,0.087410,0.733361,0.259077,0.147967,0.472822,0.824313],
        &mut out0, &mut out1
    );

    /// Check the difference from expected values.
    /// Allow for some rounding errors, which may result both from the computation
    /// and from the 6-decimal accuracy of the copy-pasted numbers.
    fn check_difference(result: &[Complex<f32>], expected: &[Complex<f32>], max_error: f32) {
        result.iter().zip(expected.iter()).for_each(|(r, e)| {
            eprintln!{"{0} {1} {2} {3}", r.re, r.im, e.re, e.im};
            assert!((r.re - e.re).abs() < max_error);
            assert!((r.im - e.im).abs() < max_error);
        });
    }
    check_difference(&out0, &expected_out0, 0.0001);
    check_difference(&out1, &expected_out1, 0.0001);
}
